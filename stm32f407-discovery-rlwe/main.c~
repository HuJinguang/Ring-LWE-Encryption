#include <stm32f4xx.h>
#include <misc.h>			 // I recommend you have a look at these in the ST firmware folder
#include <stm32f4xx_usart.h> // under Libraries/STM32F4xx_StdPeriph_Driver/inc and src

#include <stm32f4xx_usart.h>
#include <stm32f4xx_rcc.h>
#include <lwe.h>
#include <test_asm.h>
#include "global.h"
#include "speed_test.h"
#include "term_io.h"
#include "stdlib.h"
#include "knuth_yao_asm.h"





void Delay(__IO uint32_t nCount) {
  while(nCount--) {
  }
}

uint32_t TM_RNG_Get(void) {
	//Wait until one RNG number is ready
	while(RNG_GetFlagStatus(RNG_FLAG_DRDY) == RESET);

	//Get a 32bit Random number
	//return RNG_GetRandomNumber();
	return RNG->DR;
	/**** while(RNG_GetFlagStatus(RNG_FLAG_DRDY) == RESET);
	 8000276:	2001      	movs	r0, #1
 	 8000278:	f00a f8c6 	bl	800a408 <RNG_GetFlagStatus>
 	 800027c:	4603      	mov	r3, r0
 	 800027e:	2b00      	cmp	r3, #0
 	 8000280:	d0f9      	beq.n	8000276 <TM_RNG_Get+0x6>
	 *
	 *
	 **** return RNG->DR;
	 * ldr	r3, [pc, #8]	; (800028c <TM_RNG_Get+0x1c>)
 	 8000284:	689b      	ldr	r3, [r3, #8]
 	 800028c:	50060800 	.word	0x50060800

	 //equivalent:
 	 ldr r0,=0x50060800
 	 ldr r0, [r0, #8]
	 */

	//#define PERIPH_BASE           ((uint32_t)0x40000000) /*!< Peripheral base address in the alias region                                */
	//#define AHB2PERIPH_BASE       (PERIPH_BASE + 0x10000000)
	//#define RNG_BASE              (AHB2PERIPH_BASE + 0x60800)
	//RNG_BASE = 0x50060800

}

/* This funcion initializes the USART1 peripheral
 * 
 * Arguments: baudrate --> the baudrate at which the USART is 
 * 						   supposed to operate
 */
/*
void init_USART1(uint32_t baudrate){
	

	GPIO_InitTypeDef GPIO_InitStruct; // this is for the GPIO pins used as TX and RX
	USART_InitTypeDef USART_InitStruct; // this is for the USART1 initilization
	NVIC_InitTypeDef NVIC_InitStructure; // this is used to configure the NVIC (nested vector interrupt controller)
	
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE);
	
	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOB, ENABLE);

	GPIO_InitStruct.GPIO_Pin = GPIO_Pin_6 | GPIO_Pin_7; // Pins 6 (TX) and 7 (RX) are used
	GPIO_InitStruct.GPIO_Mode = GPIO_Mode_AF; 			// the pins are configured as alternate function so the USART peripheral has access to them
	GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;		// this defines the IO speed and has nothing to do with the baudrate!
	GPIO_InitStruct.GPIO_OType = GPIO_OType_PP;			// this defines the output type as push pull mode (as opposed to open drain)
	GPIO_InitStruct.GPIO_PuPd = GPIO_PuPd_UP;			// this activates the pullup resistors on the IO pins
	GPIO_Init(GPIOB, &GPIO_InitStruct);					// now all the values are passed to the GPIO_Init() function which sets the GPIO registers
	
	GPIO_PinAFConfig(GPIOB, GPIO_PinSource6, GPIO_AF_USART1); //
	GPIO_PinAFConfig(GPIOB, GPIO_PinSource7, GPIO_AF_USART1);
	
	USART_InitStruct.USART_BaudRate = baudrate;				// the baudrate is set to the value we passed into this init function
	USART_InitStruct.USART_WordLength = USART_WordLength_8b;// we want the data frame size to be 8 bits (standard)
	USART_InitStruct.USART_StopBits = USART_StopBits_1;		// we want 1 stop bit (standard)
	USART_InitStruct.USART_Parity = USART_Parity_No;		// we don't want a parity bit (standard)
	USART_InitStruct.USART_HardwareFlowControl = USART_HardwareFlowControl_None; // we don't want flow control (standard)
	USART_InitStruct.USART_Mode = USART_Mode_Tx | USART_Mode_Rx; // we want to enable the transmitter and the receiver
	USART_Init(USART1, &USART_InitStruct);					// again all the properties are passed to the USART_Init function which takes care of all the bit setting
	
	USART_ITConfig(USART1, USART_IT_RXNE, ENABLE); // enable the USART1 receive interrupt 
	
	NVIC_InitStructure.NVIC_IRQChannel = USART1_IRQn;		 // we want to configure the USART1 interrupts
	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;// this sets the priority group of the USART1 interrupts
	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;		 // this sets the subpriority inside the group
	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;			 // the USART1 interrupts are globally enabled
	NVIC_Init(&NVIC_InitStructure);							 // the properties are passed to the NVIC_Init function which takes care of the low level stuff	

	// finally this enables the complete USART1 peripheral
	USART_Cmd(USART1, ENABLE);
}
*/
/* This function is used to transmit a string of characters via 
 * the USART specified in USARTx.
 * 
 * It takes two arguments: USARTx --> can be any of the USARTs e.g. USART1, USART2 etc.
 * 						   (volatile) char *s is the string you want to send
 * 
 * Note: The string has to be passed to the function as a pointer because
 * 		 the compiler doesn't know the 'string' data type. In standard
 * 		 C a string is just an array of characters
 * 
 * Note 2: At the moment it takes a volatile char because the received_string variable
 * 		   declared as volatile char --> otherwise the compiler will spit out warnings
 * */
/*

#define MAX_STRLEN 12 // this is the maximum string length of our string in characters
volatile char received_string[MAX_STRLEN+1]; // this will hold the recieved string

void USART_puts(USART_TypeDef* USARTx, volatile char *s){

	while(*s){
		// wait until data register is empty
		while( !(USARTx->SR & 0x00000040) ); 
		USART_SendData(USARTx, *s);
		*s++;
	}
}*/

void initAll ()
{
	//init_USART1(115200); // initialize USART1 @ 9600 baud
	comm_init();

	//RNG Peripheral enable
	RCC_AHB2PeriphClockCmd(RCC_AHB2Periph_RNG, ENABLE);
	RNG_Cmd(ENABLE);
}


void get_rand_input(int i, uint32_t large1[M],uint32_t large2[M])
{
	int rnd1,rnd2,j;
	srand(i);
	if (i==0)
	{
		for (j=0; j<M/2; j++)
		{
			rnd1=2*j;
			rnd2=2*j+1;
			large1[j]=(rnd1&0xffff)+((rnd2&0xffff)<<16);
			large2[2*j]=rnd1;
			large2[2*j+1]=rnd2;
		}
	}
	else
	{
		for (j=0; j<M/2; j++)
		{
			rnd1=rand()&COEFFICIENT_ALL_ONES;
			rnd2=rand()&COEFFICIENT_ALL_ONES;
			large1[j]=(rnd1&0xffff)+((rnd2&0xffff)<<16);
			large2[2*j]=rnd1;
			large2[2*j+1]=rnd2;
		}
	}
}




/*
#ifdef NTT512
#else
uint16_t primrt_inv_omega_table[7] = {7680,3383,5756,1728,7584,6569,6601};
uint16_t primrt_omega_table_asm[8] = {7680,4298,6468,849,2138,3654,1714,5118};
#endif*/


#ifdef NTT512
	uint16_t primrt_table[8]={12288,1479,8246,4134,6429,1351,7678,7935};
	uint16_t omega_table[8] ={1479,8246,4134,6429,1351,7678,7935,5559};
	uint16_t primrt_omega_table[9]={12288,1479,8246,4134,6429,1351,7678,7935,5559};
	uint16_t primrt_inv_omega_table[8] = {12288,10810,7143,10984,3542,4821,1170,5755};
	#define FWD_CONST1 5559
	#define FWD_CONST2 6843
#else
	uint16_t primrt_inv_omega_table[7] = {7680,3383,5756,1728,7584,6569,6601};
	uint16_t primrt_table[7]={7680,4298,6468,849,2138,3654,1714};
	uint16_t omega_table[7] ={4298,6468,849,2138,3654,1714,5118};
	uint16_t primrt_omega_table[8]={7680,4298,6468,849,2138,3654,1714,5118};


	#define FWD_CONST1 5118
	#define FWD_CONST2 1065
#endif

void print_array(uint32_t a[])
{
	for (int i=0; i<M; i++)
	{
		xprintf("%d ",a[i]);
	}
}

int main (void)
{
	// Initialize everything
	initAll();

	int i;
	uint32_t j,num,num1,num2,fail,large1[M],large2[M],large3[M],large4[M],large5[M],large6[M],large_m[M],large_m_asm[M/2],large_c1[M],large_c2[M],large_c1_asm[M/2],large_c2_asm[M/2],large_a[M],large_p[M],large_r2[M];
	uint32_t small1_0[M/2],small1_1[M/2],small2_0[M/2],small2_1[M/2];
	uint32_t rnd,rnd_rem,rnd1,rnd2;
	int num16,num32;

	// Clear up terminal
	xputs("\n\n[Start]\n\n");

	//rnd = TM_RNG_Get();
	//xprintf("rnd:%u\n",rnd);

#ifdef PERFORM_TESTS
	xprintf("knuth_yao_asm:");
	fail=0;
	for (i=0x3F0; i<10000; i++)
	{
		if ((i%100)==0)
			xprintf(".");
		srand(i);
		knuth_yao_asm(large1);

		srand(i);
		knuth_yao2(large2);

		if (!compare_large_simd(large1,large2))
		{
			fail=1;
			break;
		}
	}
	if (fail==1)
	{
		xprintf("FAIL i=%x\n",i);
	}
	else
	{
		xprintf("OK\n");
	}
#ifdef PERFORM_MODULO_TESTS
	xputs("umod_asm:");
	fail=0;
	for (i=0; ((i<100000) && (fail==0)); i++)
	{
		num16=(rand());
		if (umod_asm(num16)!=num16%7681)
		{
			fail=1;
			break;
		}
	}
	if (fail==1)
		xprintf("FAIL i=%x\n",i);
	else
		xprintf("OK\n");

	xputs("umod_div_asm:");
	fail=0;
	for (i=0; ((i<100000) && (fail==0)); i++)
	{
		//num16=(rand());
		num16=i;
		if (umod_div_asm(num16)!=num16%7681)
		{
			fail=1;
			break;
		}
	}
	if (fail==1)
		xprintf("FAIL i=%x\n",i);
	else
		xprintf("OK\n");


	xputs("smod_asm:");
	fail=0;
	for (i=0; ((i<100000) && (fail==0)); i++)
	{
		srand(i);
		rnd1=rand()&0xffff;
		rnd2=rand()&0xffff;

		if (rnd1<rnd2)
			num16=rnd1-rnd2;
		else
			num16=(rnd2-rnd1);

		num32=smod_asm(num16);
		//num32=num16%7681;
		if (num16<0)
			num32=num32+7681;
		num16=mod(num16);
		if (num32!=num16)
		{
			fail=1;
			break;
		}
	}
	if (fail==1)
		xprintf("FAIL i=%x\n",i);
	else
		xprintf("OK\n");

	xputs("mod_asm2:");
	fail=0;
	for (i=0; ((i<100000) && (fail==0)); i++)
	{
		srand(i);
		rnd1=rand()&0xffff;
		rnd2=rand()&0xffff;

		if (rnd1<rnd2)
			num16=rnd1-rnd2;
		else
			num16=(rnd2-rnd1);

		num32=mod_asm2(num16);
		num16=mod(num16);
		if (num32!=num16)
		{
			fail=1;
			break;
		}
	}
	if (fail==1)
		xprintf("FAIL i=%x\n",i);
	else
		xprintf("OK\n");

	xputs("mod_asm3:");
	fail=0;
	for (i=0; ((i<100000) && (fail==0)); i++)
	{
		srand(i);
		rnd1=rand()&0xffff;
		rnd2=rand()&0xffff;

		if (rnd1<rnd2)
			num16=rnd1-rnd2;
		else
			num16=(rnd2-rnd1);


		num32=mod_asm3(num16);
		num16=mod(num16);
		if (num32!=num16)
		{
			fail=1;
			break;
		}
	}
	if (fail==1)
		xprintf("FAIL i=%x\n",i);
	else
		xprintf("OK\n");

	xputs("mod_asm4:");
	fail=0;
	for (i=0; ((i<100000) && (fail==0)); i++)
	{
		srand(i);
		rnd1=rand()&0xffff;
		rnd2=rand()&0xffff;

		if (rnd1<rnd2)
			num16=rnd1-rnd2;
		else
			num16=(rnd2-rnd1);

		num32=mod_asm4(num16);
		num16=mod(num16);
		if (num32!=num16)
		{
			fail=1;
			break;
		}
	}
	if (fail==1)
		xprintf("FAIL i=%x\n",i);
	else
		xprintf("OK\n");

	xputs("mod_asm5:");
	fail=0;
	for (i=-50000; ((i<50000) && (fail==0)); i++)
	{
		srand(i);
		rnd1=rand()&0xffff;
		rnd2=rand()&0xffff;


		num16=rnd1-rnd2;
		//num16=i;

		num32=mod_asm5(num16);
		num16=mod(num16);
		if (num32!=num16)
		{
			fail=1;
			break;
		}
	}
	if (fail==1)
		xprintf("FAIL i=%x\n",i);
	else
		xprintf("OK\n");

	xputs("mod_asm:");
	fail=0;
	for (i=0; ((i<100000) && (fail==0)); i++)
	{
		srand(i);
		rnd1=rand()&0xffff;
		rnd2=rand()&0xffff;

		if (rnd1<rnd2)
			num16=(rnd1-rnd2);
		else
			num16=(rnd2-rnd1);

		rnd = mod_asm(num16);
		rnd2 = mod(num16);

		if (rnd!=rnd2)
		{
			fail=1;
			break;
		}
	}
	if (fail==1)
		xprintf("FAIL i=%x\n",i);
	else
		xprintf("OK\n");

	xputs("mod_asm_simd:");
	fail=0;
	for (i=0; ((i<100000) && (fail==0)); i++)
	{
		rnd1=rand()&0xffff;
		rnd2=rand()&0xffff;

		num1=umod_asm_simd(rnd1+(rnd2<<16));

		if ((mod(rnd1) != (num1&0xffff)) || (mod(rnd2) != ((num1>>16)&0xffff)))
		{
			fail=1;
			break;
		}
	}
	if (fail==1)
		xprintf("FAIL i=%x\n",i);
	else
		xprintf("OK\n");
#endif

#ifdef PERFORM_SMALL_TESTS
	xputs("coefficient_add_asm:");
	fail=0;
	for (i=0; ((i<100) && (fail==0)); i++)
	{
		srand(i);
		for (j=0; j<M/2; j++)
		{
			rnd1=rand()&COEFFICIENT_ALL_ONES;
			rnd2=rand()&COEFFICIENT_ALL_ONES;
			rnd1=j+0xFFF;
			rnd2=j+1+0xFFF;
			large1[j]=(rnd1&0xffff)+((rnd2&0xffff)<<16);
			small1_0[j]=rnd1;
			small1_1[j]=rnd2;

			rnd1=rand();
			rnd2=rand();
			rnd1=j+0xFFF;
			rnd2=j+1+0xFFF;
			large2[j]=(rnd1&0xffff)+((rnd2&0xffff)<<16);
			small2_0[j]=rnd1;
			small2_1[j]=rnd2;
		}

		coefficient_add_asm(large1,large1,large2);
		coefficient_add(small1_0,small1_1,small2_0,small2_1);

		if (!compare_simd(small1_0,small1_1,large1))
		{
			fail=1;
			break;
		}
	}
	if (fail==1)
		xprintf("FAIL i=%x\n",i);
	else
		xprintf("OK\n");

	xprintf("coefficient_mul_add: ");
	fail=0;
	for (i=0; i<1000; i++)
	{
		uint32_t large1[M],large2[M],large3[M],large1_asm[M/2],large2_asm[M/2],large3_asm[M/2],res[M],res_asm[M/2];
		//Test knuth-yao
		srand(i);
		int j;
		get_ntt_random_numbers(large1_asm,large1,i);
		get_ntt_random_numbers(large2_asm,large2,i+1);
		get_ntt_random_numbers(large3_asm,large3,i+2);

		coefficient_mul_add_asm(res_asm,large1_asm,large2_asm,large3_asm);

		coefficient_mul_add2(res,large1,large2,large3);

		//if ((!compare(a_0,b_0)) || (!compare(a_1,b_1)))
		if (!compare_large_simd(res_asm,res))
		{
			fail=1;
			break;
		}
	}
	if (fail==1)
		xprintf("BAD!\n");
	else
		xprintf("OK!\n");

		//r2_gen2
		fail = 0;
		xprintf("r2_gen_asm: ");
		for (i=0; i<100; i++)
		{
			//Test knuth-yao
			srand(i);
			r2_gen_asm(large1);

			srand(i);
			r2_gen2(large2);

			if (!compare_large_simd(large1,large2))
			{
				fail=1;
				break;
			}
		}
		if (fail==1)
			xprintf("BAD\n");
		else
			xprintf("OK\n");


	xputs("bitreverse_asm:");
	fail=0;
	for (i=0; ((i<100) && (fail==0)); i++)
	{
		xputc('.');
		get_ntt_random_numbers(large1,large2,i);

		bitreverse_asm(large1);
		bitreverse2(large2);

		if (!compare_large_simd(large1,large2))
		{
			fail=1;
			break;
		}
		xputc('.');
	}
	if (fail==1)
		xprintf("FAIL i=%x\n",i);
	else
		xprintf("OK\n");


	xputs("coefficient_mul_asm:");
	fail=0;
	for (i=0; ((i<100) && (fail==0)); i++)
	{
		srand(i);
		for (j=0; j<M/2; j++)
		{
			rnd1=rand()&COEFFICIENT_ALL_ONES;
			rnd2=rand()&COEFFICIENT_ALL_ONES;
			rnd1=j+0xFFF;
			rnd2=j+1+0xFFF;
			large1[j]=(rnd1&0xffff)+((rnd2&0xffff)<<16);
			small1_0[j]=rnd1;
			small1_1[j]=rnd2;

			rnd1=rand();
			rnd2=rand();
			rnd1=j+0xFFF;
			rnd2=j+1+0xFFF;
			large2[j]=(rnd1&0xffff)+((rnd2&0xffff)<<16);
			small2_0[j]=rnd1;
			small2_1[j]=rnd2;
		}

		coefficient_mul_asm(large1,large1,large2);
		coefficient_mul(small1_0,small1_1,small2_0,small2_1);

		if (!compare_simd(small1_0,small1_1,large1))
		{
			fail=1;
			break;
		}
	}
	if (fail==1)
		xprintf("FAIL i=%x\n",i);
	else
		xprintf("OK\n");


	xputs("a_gen_asm:");
	fail=0;
	for (i=0; ((i<100) && (fail==0)); i++)
	{
		srand(i);
		a_gen_asm(large1);
		srand(i);
		a_gen2(large2);

		if (!compare_large_simd(large1,large2))
		{
			fail=1;
			break;
		}
	}
	if (fail==1)
		xprintf("FAIL i=%x\n",i);
	else
		xprintf("OK\n");

	xputs("r1_gen_asm:");
	fail=0;
	for (i=0; ((i<100) && (fail==0)); i++)
	{
		srand(i);
		r1_gen_asm(large1);
		//knuth_yao_asm(large1);
		//fwd_ntt_asm(large1);

		srand(i);
		r1_gen2(large2);

		if (!compare_large_simd(large1,large2))
		{
			fail=1;
			break;
		}
	}
	if (fail==1)
		xprintf("FAIL i=%x\n",i);
	else
		xprintf("OK\n");

	xputs("coefficient_sub_asm:");
	fail=0;
	for (i=0; ((i<100) && (fail==0)); i++)
	{
		srand(i);
		for (j=0; j<M/2; j++)
		{
			rnd1=rand()&COEFFICIENT_ALL_ONES;
			rnd2=rand()&COEFFICIENT_ALL_ONES;
			rnd1=j+0xFFF;
			rnd2=j+1+0xFFF;
			large1[j]=(rnd1&0xffff)+((rnd2&0xffff)<<16);
			small1_0[j]=rnd1;
			small1_1[j]=rnd2;

			rnd1=rand();
			rnd2=rand();
			rnd1=2*j+0xFFF;
			rnd2=2*j+1+0xFFF;
			large2[j]=(rnd1&0xffff)+((rnd2&0xffff)<<16);
			small2_0[j]=rnd1;
			small2_1[j]=rnd2;
		}

		coefficient_sub_asm(large1,large1,large2);
		coefficient_sub(small1_0,small1_1,small2_0,small2_1);

		if (!compare_simd(small1_0,small1_1,large1))
		{
			fail=1;
			break;
		}
	}
	if (fail==1)
		xprintf("FAIL i=%x\n",i);
	else
		xprintf("OK\n");

	xputs("rearrange_asm:");
	fail=0;
	for (i=0; ((i<1000) && (fail==0)); i++)
	{
		get_rand_input(i,large1,large2);

		rearrange_asm(large1);
		rearrange2(large2);

		if (!compare_large_simd(large1,large2))
		{
			fail=1;
			break;
		}
	}
	if (fail==1)
		xprintf("FAIL i=%x\n",i);
	else
		xprintf("OK\n");

	xputs("fwd_ntt_parallel_asm:");
	fail=0;
	for (i=0; ((i<100) && (fail==0)); i++)
	{
		get_ntt_random_numbers(fixed_data1,large1,i);
		get_ntt_random_numbers(fixed_data2,large2,i);
		get_ntt_random_numbers(fixed_data3,large3,i);

		fwd_ntt_parallel_asm(fixed_data1);
		fwd_ntt2(large1);
		fwd_ntt2(large2);
		fwd_ntt2(large3);

		if (!compare_large_simd(fixed_data1,large1))
		{
			fail=1;
			break;
		}

		if (!compare_large_simd(fixed_data2,large2))
		{
			fail=1;
			break;
		}
		if (!compare_large_simd(fixed_data3,large3))
		{
			fail=1;
			break;
		}

	}
	if (fail==1)
		xprintf("FAIL i=%x\n",i);
	else
		xprintf("OK\n");

	xputs("fwd_ntt_asm:");
	fail=0;
	for (i=0; ((i<500) && (fail==0)); i++)
	{
		get_ntt_random_numbers(large1,large2,i);

		fwd_ntt_asm(large1);
		fwd_ntt2(large2);

		if (!compare_large_simd(large1,large2))
		{
			fail=1;
			break;
		}
	}
	if (fail==1)
		xprintf("FAIL i=%x\n",i);
	else
		xprintf("OK\n");

	xputs("inv_ntt_asm:");
	fail=0;
	for (i=0; ((i<100) && (fail==0)); i++)
	{
		get_ntt_random_numbers(large1,large2,i);

		inv_ntt_asm(large1);
		inv_ntt2(large2);

		if (!compare_large_simd(large1,large2))
		{
			fail=1;
			break;
		}
	}
	if (fail==1)
		xprintf("FAIL i=%x\n",i);
	else
		xprintf("OK\n");




	/*
	xprintf("knuth_yao_single_number_big_low_asm:");
	fail=0;
	//for (i=0xF0000000; i<0xFFFFFFFF; i++)
	for (i=0x0; i<0x529b8; i++)
	{
		//srand(i*i);
		//rnd=rand();
		//rnd=906613759; //Goes deep!
		//rnd=1220009855;//Goes toe LUT2
		srand(i*i);
		rnd=i;
		rnd_rem=32;
		//rnd=8191;
		//rnd_rem=13;
		num1=0;
		for (j=0; j<INNER_REPEAT_COUNT; j++)
		{
			num1 += knuth_yao_single_number_big_low_asm(&rnd,&rnd_rem);
		}
		//xprintf("%d ",num);

		srand(i*i);
		//rnd=rand();
		//rnd=906613759; //Goes deep!
		//rnd=1220009855;//Goes toe LUT2
		rnd=i;
		rnd_rem=32;
		//rnd=8191;
		//rnd_rem=13;
		num2=0;
		for (j=0; j<INNER_REPEAT_COUNT; j++)
		{
			num2 += knuth_yao_single_number(&rnd);
		}
		if (num1!=num2)
		{
			fail=1;
			break;
		}
	}
	if (fail==1)
	{
		xprintf("FAIL i=%x\n",i);
	}
	else
	{
		xprintf("OK\n");
	}
	*/
#endif //PERFORM_SMALL_TESTS




#ifdef PERFORM_BIG_TESTS
	xprintf("RLWE_enc: ");
	for (i=0; i<10; i++)
	{
		//Test knuth-yao
		srand(i);
		message_gen2(large_m);

		srand(i);
		key_gen2(large4,large5,large6); //a=large, p=large2, r2=large3
		srand(i);
		RLWE_enc2(large4,large_c1,large_c2,large_m,large5);

		srand(i);
		key_gen_asm(large4,large5,large6);
		srand(i);
		message_gen_asm(large_m_asm);
		srand(i);
		RLWE_enc_asm(large4,large_c1_asm,large_c2_asm,large_m_asm,large5);

		if (!compare_large_simd(large_c1_asm,large_c1))
		{
			fail=1;
			break;
		}

		if (!compare_large_simd(large_c2_asm,large_c2))
		{
			fail=1;
			break;
		}
	}
	if (fail==1)
		xprintf("FAIL i=%x\n",i);
	else
		xprintf("OK\n");

	xprintf("RLWE_dec: ");
	for (i=0; i<10; i++)
	{
		//Test knuth-yao
		srand(i);
		message_gen2(large_m);

		srand(i);
		key_gen2(large4,large5,large6); //a=large4, p=large5, r2=large6
		srand(i);
		RLWE_enc2(large4,large_c1,large_c2,large_m,large5);
		RLWE_dec2(large_c1,large_c2,large6);

		srand(i);
		key_gen_asm(large4,large5,large6);//a=large4, p=large5, r2=large6
		srand(i);
		message_gen_asm(large_m_asm);
		srand(i);
		RLWE_enc_asm(large4,large_c1_asm,large_c2_asm,large_m_asm,large5);
		RLWE_dec_asm(large_c1_asm,large_c2_asm,large6);

		if (!compare_large_simd(large_c1_asm,large_c1))
		{
			fail=1;
			break;
		}
	}
	if (fail==1)
		xprintf("FAIL i=%x\n",i);
	else
		xprintf("OK\n");

	fail = 0;
	xprintf("Enc2/Dec2:");
	for(i=0; (i<50) && (fail==0); i++)
	{
		srand(i);
		message_gen2(large_m);

		bitreverse2(large_m);

		key_gen2(large_a,large_p,large_r2); //a=large, p=large2, r2=large3


		RLWE_enc2(large_a,large_c1,large_c2,large_m,large_p);


		RLWE_dec2(large_c1,large_c2,large_r2);

		for(j=0; j<M; j++)
		{
			if ((large_c1[j]>QBY4) && (large_c1[j]<QBY4_TIMES3))
				large_c1[j] = 1;
			else
				large_c1[j] = 0;
		}

		//Determine if the decryption was correct:
		bitreverse2(large_m);

		rearrange_for_final_test(large_c1,large1);
		//bitreverse2(large_c1);
		for (j=0; j<M; j++)
		{
			if (large_m[j]!=large1[j])
			{
				fail=1;
				break;
			}
		}
		if (fail==1)
			break;
	}
	if (fail==1)
		xprintf("FAIL i=%x\n",i);
	else
		xprintf("OK\n");

	fail = 0;
	xprintf("Enc_asm/Dec_asm:");
	uint32_t error_count = 0;
	uint64_t idx = 0;
#ifdef PERFORM_DECRYPTION_ERROR_TEST
	for(idx=0; (idx<5000000); idx++)
#else
	for(idx=0; (idx<50); idx++)
#endif
	{
		if (idx%100==0) xputc('.');

		srand(idx);

		if (idx==0)
		{
			for (j=0; j<M/2; j++)
			{
				if (j<M/4)
				{
					large_m_asm[j]=1+(1<<16);
				}
				else
				{
					large_m_asm[j]=0;
				}
				large4[j]=1+(1<<16);
				large5[j]=1+(1<<16);
				large6[j]=1+(1<<16);
			}
		}
		else
		{
			message_gen_asm(large_m_asm);
			key_gen_asm(large4,large5,large6); //a=large4, p=large5, r2=large6
		}
		bitreverse_asm(large_m_asm);

		RLWE_enc_asm(large4,large_c1_asm,large_c2_asm,large_m_asm,large5);

		RLWE_dec_asm(large_c1_asm,large_c2_asm,large6);
		uint32_t tmp1,tmp2;
		for(j=0; j<M; j++)
		{
			tmp1 = large_c1_asm[j]&0xffff;
			tmp2 = (large_c1_asm[j]>>16)&0xffff;

			if ((tmp1>QBY4) && (tmp1<QBY4_TIMES3))
				tmp1 = 1;
			else
				tmp1 = 0;

			if ((tmp2>QBY4) && (tmp2<QBY4_TIMES3))
				tmp2 = 1;
			else
				tmp2 = 0;

			large_c1_asm[j] = tmp1 + (tmp2<<16);
		}

		//Determine if the decryption was correct:
		bitreverse_asm(large_m_asm);

		rearrange_for_final_test_asm(large_c1_asm,large1);
		for (j=0; j<M/2; j++)
		{
			if (large_m_asm[j]!=large1[j])
			{
				xprintf("idx=%d j=%d ",idx,j);
				fail=1;
				break;
			}
		}
		if (fail==1)
			break;
	}
#ifndef PERFORM_DECRYPTION_ERROR_TEST
	if (fail==1)
		xprintf("FAIL idx=%d\n",idx);
	else
		xprintf("OK\n");
#endif

	//key_gen_asm
	fail = 0;
	xprintf("key_gen_asm: ");
	for (i=0; i<100; i++)
	{
		//Test knuth-yao
		srand(i);
		key_gen_asm(large1,large2,large3);

		srand(i);
		key_gen2(large4,large5,large6);

		if (!compare_large_simd(large1,large4))
		{
			fail=1;
			break;
		}
		if (!compare_large_simd(large2,large5))
		{
			fail=1;
			break;
		}
		if (!compare_large_simd(large3,large6))
		{
			fail=1;
			break;
		}
	}
	if (fail==1)
		xprintf("FAIL i=%x\n",i);
	else
		xprintf("OK\n");

#endif //PERFORM_BIG_TESTS


#endif //PERFORM_TESTS

#ifdef PERFORM_SPEED_TESTS
	speed_test();
#endif

	xputs("[Done]\n\n");

	while (1)
	{

	}

	return 0;
}

/*
int main(void) {

	initAll();

	USART_puts(USART1, "Init complete! Hello World!\r\n"); // just send a message to indicate that it works


  	uint32_t large1[M], large2[M];
	int i,fail;
	xprintf("knuth_yao_asm:");
	fail=0;
	for (i=0x0; i<0xFF; i++)
	{
		srand(i);
		knuth_yao_asm(large1);

		srand(i);
		knuth_yao2(large2);

		if (!compare_large_simd(large1,large2))
		{
			fail=1;
			break;
		}
	}
	if (fail==1)
	{
		xprintf("FAIL i=%x\n",i);
	}
	else
	{
		xprintf("OK\n");
	}

  int a;
  while (1){
	  a = TM_RNG_Get();
  }
}*/

/*
// this is the interrupt request handler (IRQ) for ALL USART1 interrupts
void USART1_IRQHandler(void){
	
	// check if the USART1 receive interrupt flag was set
	if( USART_GetITStatus(USART1, USART_IT_RXNE) ){
		
		static uint8_t cnt = 0; // this counter is used to determine the string length
		char t = USART1->DR; // the character from the USART1 data register is saved in t
		
		// check if the received character is not the LF character (used to determine end of string)
		// or the if the maximum string length has been been reached

		if( (t != '\n') && (cnt < MAX_STRLEN) ){ 
			received_string[cnt] = t;
			cnt++;
		}
		else{ // otherwise reset the character counter and print the received string
			cnt = 0;
			USART_puts(USART1, received_string);
		}
	}
}
*/
