
#include "global.h"

#ifdef USE_TRNG
	#define GET_RAND\
		ldr	r0, =#RNG_ADDR;\
	 	ldr	r0, [r0, #8]
#else
	#define GET_RAND\
		push {r1,r2,r3,lr};\
		bl	rand;\
		pop {r1,r2,r3,lr};
#endif


#define GET_RAND_IF_NECESSARY(id)\
	cbnz r0,id;\
	GET_RAND;\
	id:

  .syntax unified
  .cpu cortex-m4
  .fpu softvfp
  .thumb

.section .text

  .balign  2
  .thumb
  .thumb_func
  .code 16

  .global knuth_yao_asm
  .extern knuth_yao_asm
  .type knuth_yao_asm, %function
knuth_yao_asm:
	stmdb	sp!, {r4, r5, r6, r7, r8, r9, r10, r11, lr}

	mov r11,r0 //Save *return_vals to r11

	//r0=rnd
	//r1=str return val index
	//r2=lut1
	//r3=lut1_lookup, lut2_lookup, sample,row (return values)
	//r4=tmp: sample_msb, index, column
	//r5=MODULUS
	//r6=distance (only used from lut2_lookup_continue)
	//r7=temp (clz)
	//r8=pmat_cols_small_low
	//r9=pmat_cols_small_high/lut2
	//r10=low,high
	//r11=*return_vals
	//lr=result from every second (odd numbered) calculation

	ldr r2,=lut1
	ldr r5,=MODULUS
	ldr r8,=pmat_cols_small_low
	//ldr r9,=pmat_cols_small_high
	ldr r9,=lut2
	mov r1,#0
	GET_RAND; //Get the initial random number
	//ldr	r0, =#RNG_ADDR
	//ldr	r0, [r0, #8]

knuth_yao_single:

	uxtb r4,r0 //r4 = index
	lsr r0,#8 //(*rnd)=(*rnd)>>8;

	GET_RAND_IF_NECESSARY(lookup_lut1)
	//ldr r2, =lut1
	ldrb r3, [r2,r4]; //sample //sample (r3) = lut1[index]; //256 elements in lut1

	lsrs r4,r3,#5 //sample_msb = sample & 16 = (2^4) = fifth bit
	bcs lut1_no_success

lut1_success_continue:
	//lut1 lookup SUCCESS
	and r3,r3,#31;//sample = sample & 0xf;
	lsrs r0,#1 //rnd (r0) = rnd >> 1
	bcc cleanup //rnd_rem-- in cleanup

	sub r3,r5,r3 ////sample (r3) = (MODULUS - sample);
	b cleanup //rnd_rem-- in cleanup

lut1_no_success:
	//lut1 lookup FAIL: Now try lut2 lookup

	//Check if enough bits exist inside rnd
	clz r4,r0
	cmp r4,#27
	ble lut2_lookup_continue
	GET_RAND

lut2_lookup_continue:
	and r6,r3,#7; //distance(r6) = sample(r3) & 7;
	and r4,r0,#0x1f //r4 = (*rnd)&0x1f
	add r4,r4,r6,lsl #5 //index (r4) = [(*rnd)&0x1f] (r4) + 32*distance(r6);

	lsr r0,#5; //(*rnd) = (*rnd)>>5;

	GET_RAND_IF_NECESSARY(lut2_lookup_continue2)

	//ldr r9, =lut2
	ldrb r3, [r9,r4]; //sample (r3) = lut2[index]; //224 elements in lut2

	lsrs r4,r3,#6 //The sixth bit (2^5) represents the sample_msb
	bcs lut2_no_success_start_real_kn

	//lut2 SUCCESS!
	and r3,#31 //sample (r3) = sample & 31;

	lsrs r0,#1
	bcc cleanup //rnd_rem-- in cleanup

	sub r3,r5,r3 //if ((*rnd)&1) sample (r3) = (MODULUS - sample)
	b cleanup //rnd_rem-- in cleanup

lut2_no_success_start_real_kn:
	//Now we perform bit scanning with knuth-yao
	and r6,r3,#15; //distance (r6) = sample(r3) & 15;

	//ldr r8,=pmat_cols_small_low

	//for(column=0; column<HAMMING_TABLE_SIZE; column++) {
	mov r4,#0 //column(r4)=0
real_kn_low_loop:
	/*******Start of (big) inner loop*******/

	/*distance = distance*2 + ((*rnd)&1);*/
	and r10,r0,#1 			//r10=((*rnd)&1);
	lsrs r0,#1 				//(*rnd)=(*rnd)>>1;
	add r6,r10,r6,lsl #1	//distance (r6) = ((*rnd)&1) + distance*2

	GET_RAND_IF_NECESSARY(real_kn_low_loop_continue)

	ldr r10,[r8, r4, lsl #2]; //low(r10)=pmat_cols_small_low[column];
	clz r7,r10
	lsl r10,r7

	//for(row=(54-32); row>=0; row--)
	mov r3,#LOW_MSB 			//r3=row!
	sub r3,r7 					//r7=free

real_kn_low_loop_inner_continue:
	//******Start of (small) inner loop ******

	lsls r10,#1 //low(r10)=low<<1;
	bcc real_kn_low_loop_inner_continue2
	subs r6,#1 //distance (r6) = distance - (low>>31); //subtract the most significant bit
	bmi finished_exit //if (distance(r6)==-1) {

real_kn_low_loop_inner_continue2:
	subs r3,#1 //row=row-1
	bpl real_kn_low_loop_inner_continue //row>=0
	//******End of (small) inner loop ******

	add r4,#1
	cmp r4,#HAMMING_TABLE_SIZE
	bne real_kn_low_loop
	//*******End of (big) inner loop*******

	//At this point we still haven't found the gaussian sample.
	//We now have to use both the high and low values to perform the sampling.
	ldr r9,=pmat_cols_small_high
real_kn_high_loop:

	//for(column=HAMMING_TABLE_SIZE; (column<(109-13)); column++)	{
	and r10,r0,#1 			//r10=((*rnd)&1);
	lsr r0,#1 				//(*rnd)(r0)=(*rnd)>>1;
	add r6,r10,r6,lsl #1	//distance (r6) = ((*rnd)&1) + distance*2

	GET_RAND_IF_NECESSARY(real_kn_high_loop_continue)

	//***********Start of outer high loop**************

	ldr r10,[r9, r4, lsl #2]; //high(r10)=pmat_cols_small_high[column];
	clz r7,r10
	mov r3,#54 				//r3=row
	sub r3,r7 				//r7=free

	cmp r3,#LOW_MSB
	beq low_loop_init 		//if r10 is empty (r3=LOW_MSB) then there is no need to process 'high'
	lsl r10,r7 				//Remove leading zeros from high (r10)

	//for(row=54; row>(54-32); row--)
high_loop:
	//***********Start of high loop**************
	lsls r10,#1 			//low(r10)=low<<1;
	bcc high_loop_continue
	subs r6,#1 				//distance (r6) = distance - (high>>31); //subtract the most significant bit
	//bmi finished_exit //if (distance(r6)==-1) {
	bmi high_low_finished_exit //if (distance(r6)==-1) {

high_loop_continue:
	sub r3,#1 //row--
	cmp r3,#LOW_MSB
	bgt high_loop
	//***********End of high loop**************

low_loop_init:
	ldr r10,[r8, r4, lsl #2]; //low(r10)=pmat_cols_small_low[column];

	//for(row=(54-32); row>=0; row--)
low_loop:
	//***********Start of low loop**************

	lsls r10,#1 //low(r10)=low<<1;
	bcc low_loop_continue
	subs r6,#1 //distance (r6) = distance - (low>>31); //subtract the most significant bit
	//bmi finished_exit //if (distance(r6)==-1) {
	bmi high_low_finished_exit

low_loop_continue:
	subs r3,#1 //row--
	bpl low_loop
	//***********End of low loop**************

	add r4,#1 //column(r4) ++
	b real_kn_high_loop //No tests are necessary: the loop should end in here
	//***********End of outer high loop**************

high_low_finished_exit:
	ldr r9,=lut2 //Store @lut2 inside r9

finished_exit:
	//FINISHED: Exit!
	//NB: r3 is used as an input here!
	lsrs r0,#1 //r0 = random number
	bcc cleanup //rnd_rem-- in cleanup

	sub r3,r5,r3 //sample (r3) = (MODULUS - sample); //9th bit in rnd is the sign

cleanup:
	clz r6,r0
	cmp r6,#(24)
	ble knuth_yao_asm_done //if ((*rnd_rem)<8)
	GET_RAND

	ble knuth_yao_asm_done //if ((*rnd_rem)<8)
	GET_RAND

knuth_yao_asm_done:

	//We combine two results into a single word
	lsrs r7,r1,#1
	bcs store_result

	//Store result in r14 if r1=odd
	mov r14,r3
	add r1,#1
	b knuth_yao_single //Jump to knuth_yao_single

	//Store r14 + result in memory if r1=even
store_result:
	add r3,r14,r3,lsl #16
	sub r4,r1,#1
	str r3,[r11,r4,lsl #1]; //Write rnd (r3) to [r11]
	add r1,#1
	cmp r1,#256 //Check if r1==256
	bne knuth_yao_single //Jump to knuth_yao_single

	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, r10, r11, pc}
